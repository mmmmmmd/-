Java虚拟机栈
　　Java Virtual Machine Stacks，线程私有，生命周期与线程相同，描述的是
Java方法执行的内存模型：每一个方法执行的同时都会创建一个栈帧（Stack Frame
），由于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法的执行
就对应着栈帧在虚拟机栈中的入栈，出栈过程。


局部变量表：
存放编译期可知的各种基本数据类型、对象引用类型和returnAddress类型（指向一
条字节码指令的地址：函数返回地址）。
long、double占用两个局部变量控件Slot。
局部变量表所需的内存空间在编译期确定，当进入一个方法时，方法在栈帧中所需要分
配的局部变量控件是完全确定的，不可动态改变大小。
异常：线程请求的栈帧深度大于虚拟机所允许的深度---StackOverFlowError，如
果虚拟机栈可以动态扩展（大部分虚拟机允许动态扩展，也可以设置固定大小的虚拟机
栈），但是无法申请到足够的内存---OutOfMemorError。


操作数栈：
后进先出LIFO，最大深度由编译期确定。栈帧刚建立使，操作数栈为空，执行方法操作
时，操作数栈用于存放JVM从局部变量表复制的常量或者变量，提供提取，及结果入栈，
也用于存放调用方法需要的参数及接受方法返回的结果。
操作数栈可以存放一个jvm中定义的任意数据类型的值。
在任意时刻，操作数栈都一个固定的栈深度，基本类型除了long、double占用两个深度，其它占用一个深度


动态连接：
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用
是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符
号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这
些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如f
inal、static域等），称为静态解析，另一部分将在每一次的运行期间转化为
直接引用，这部分称为动态连接。


方法返回地址：
当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返
回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用
何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继
续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方
法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为
返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是
要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。方法退出的过程
实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的
局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，
调整PC计数器的值以指向方法调用指令后面的一条指令。