"=="运算符用来比较两个变量的值是否相等，也就是说该运算符用于比较变量对应的内存
中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量的值是否相等只能
使用"=="运算符
可以理解为“==”是比较内存中存储的数据是否相等。
为什么基本变量可以用"=="直接进行比较而引用变量不行呢？
因为基本变量的内存中存储的是直接的数值，例如：
int a=5;
那么a所指向的内存中存储的数值就是5、
而引用变量为什么不能直接用“==”进行比较呢?
因为引用变量中所存储的数值是一个地址，该地址中存储的才是数值，例如：
Integer a=5;
a中存储的是一个地址，而该地址中存储的数值才是5。


equals()方法也用来比较两个变量的值是否相等，该方法的默认实现（Object类中的实现）
是“==”，也就是该方法的默认实现和“==”的作用是一样的也是比较内存中存储的值。例如:
class Object{
    ......
        public boolean equals(Object o){
        return this==o;
        }
    ......
}
但是String类中对其进行了重写，所以我们用String类的对象调用该方法所获取的结果是
两个字符串的内容是否相等...



hashCode()方法的返回值和equals()方法的关系如下：
x.equals(y)返回true，即两个对象根据equals()方法比较是相等的，那么调用这两个对
象中任意一个对象的hashCode()方法都必须产生同样的整数结果。如果x.equals(y)返回
false，即两个对象根据equals()方法比较是不相等的，那么x和y的hashCode()方法的返
回值有可能相等，也有可能不相等。反之，hashCode()方法的返回值不相等，一定能推
出equals()方法的返回值也不相等，而hashCode()方法的返回值相等，equals()方法的
返回值则可能相等，也可能不相等。
